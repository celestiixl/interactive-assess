"use client";

import React, { useMemo, useState } from "react";

export type DonutSegment = {
  key: string; // e.g. "BIO.10C" or "BIO.2"
  label: string; // human label
  value: number; // 0-100 mastery
  weight?: number; // slice size weight
  group?: string; // e.g. "BIO.10" or "BIO.2"
};

type RingArc = {
  key: string;
  label: string;
  weight: number;
  value: number;
  groupKey?: string;
  groupLabel?: string;
  color: string;
};

function polarToXY(cx: number, cy: number, r: number, a: number) {
  return { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
}

function arcPath(
  cx: number,
  cy: number,
  rOuter: number,
  rInner: number,
  start: number,
  end: number,
) {
  const large = end - start > Math.PI ? 1 : 0;
  const p1 = polarToXY(cx, cy, rOuter, start);
  const p2 = polarToXY(cx, cy, rOuter, end);
  const p3 = polarToXY(cx, cy, rInner, end);
  const p4 = polarToXY(cx, cy, rInner, start);

  return [
    `M ${p1.x.toFixed(3)} ${p1.y.toFixed(3)}`,
    `A ${rOuter} ${rOuter} 0 ${large} 1 ${p2.x.toFixed(3)} ${p2.y.toFixed(3)}`,
    `L ${p3.x.toFixed(3)} ${p3.y.toFixed(3)}`,
    `A ${rInner} ${rInner} 0 ${large} 0 ${p4.x.toFixed(3)} ${p4.y.toFixed(3)}`,
    "Z",
  ].join(" ");
}

function mixHex(a: string, b: string, t: number) {
  const pa = parseInt(a.slice(1), 16);
  const pb = parseInt(b.slice(1), 16);
  const ar = (pa >> 16) & 255,
    ag = (pa >> 8) & 255,
    ab = pa & 255;
  const br = (pb >> 16) & 255,
    bg = (pb >> 8) & 255,
    bb = pb & 255;
  const rr = Math.round(ar + (br - ar) * t);
  const rg = Math.round(ag + (bg - ag) * t);
  const rb = Math.round(ab + (bb - ab) * t);
  const toHex = (n: number) => n.toString(16).padStart(2, "0");
  return `#${toHex(rr)}${toHex(rg)}${toHex(rb)}`;
}

function hashStr(s: string) {
  let h = 2166136261;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }

function toPct(v: number) {
  const n = Number(v);
  if (!Number.isFinite(n)) return 0;
  // If it looks like a fraction (0..1), convert to percent
  if (n <= 1.5) return Math.max(0, Math.min(100, n * 100));
  return Math.max(0, Math.min(100, n));
}


function toPct(v: number) {
  const n = Number(v);
  if (!Number.isFinite(n)) return 0;
  // If it looks like a fraction (0..1), convert to percent
  if (n <= 1.5) return Math.max(0, Math.min(100, n * 100));
  return Math.max(0, Math.min(100, n));
}

  return h >>> 0;
}

// Outer ring: base color by cluster (BIO.5 .. BIO.13),
// then per-sub-TEKS get a consistent shade of that base.
const OUTER_CLUSTER_BASE: Record<string, string> = {
  "BIO.5":  "#2563eb", // blue
  "BIO.6":  "#7c3aed", // violet
  "BIO.7":  "#db2777", // pink
  "BIO.8":  "#f59e0b", // amber
  "BIO.9":  "#16a34a", // green
  "BIO.10": "#dc2626", // red
  "BIO.11": "#0ea5e9", // sky
  "BIO.12": "#14b8a6", // teal
  "BIO.13": "#84cc16", // lime
};

// How many shade steps we want per cluster
const OUTER_SHADE_STEPS = 5;

// Create a shade by mixing toward white (lighter) or slate (darker) a bit.
// This keeps things muted but distinct.
function shadeOf(baseHex: string, idx: number) {
  const t = idx / (OUTER_SHADE_STEPS - 1); // 0..1
  // Mix slightly toward white for higher idx
  return mixHex(baseHex, "#ffffff", 0.10 + 0.22 * t);
}

function clusterKeyFromSegmentKey(key: string) {
  // "BIO.10C" -> "BIO.10"
  const m = key.match(/^(BIO\.[0-9]+)/);
  return m ? m[1] : key;
}

// For sub-keys like BIO.10A/B/C/D we use the letter to pick a shade.
// For numeric-only keys, hash it.
function outerColorFor(key: string) {
  const cluster = clusterKeyFromSegmentKey(key);
  const base = OUTER_CLUSTER_BASE[cluster] ?? "#2563eb";

  const m = key.match(/^[A-Z]+\.[0-9]+([A-Z])); // captures trailing letter
  let idx = 0;

  if (m && m[1]) {
    idx = (m[1].charCodeAt(0) - 65) % OUTER_SHADE_STEPS; // A->0, B->1...
  } else {
    idx = hashStr(key) % OUTER_SHADE_STEPS;
  }

  return shadeOf(base, idx);
}

// Inner ring palette: calm “sand” with slight per-slice variation
const INNER_COLORS = [
  "#94a3b8",  // slate
  "#60a5fa",  // blue
  "#34d399",  // green
  "#f59e0b",  // amber
];

function innerColorFor(groupKey: string) {
  return INNER_COLORS[hashStr(groupKey) % INNER_COLORS.length];
}

const PRACTICE_KEYS = ["BIO.1", "BIO.2", "BIO.3", "BIO.4"] as const;

const PRACTICE_LABELS: Record<(typeof PRACTICE_KEYS)[number], string> = {
  "BIO.1": "BIO.1 • Ask questions, plan & conduct investigations safely",
  "BIO.2": "BIO.2 • Analyze & interpret data",
  "BIO.3": "BIO.3 • Develop explanations & communicate findings",
  "BIO.4": "BIO.4 • Scientists, research, and societal impact",
};

function isPracticeClusterKey(k: string) {
  return PRACTICE_KEYS.includes(k as any);
}

export function MasteryDonut({
  segments,
  size = 420,
}: {
  segments: DonutSegment[];
  size?: number;
}) {
  const [hoverKey, setHoverKey] = useState<string | null>(null);

  const { outer, inner, overall, hoverText } = useMemo(() => {
    const norm = segments.map((s) => ({
        ...s,
        value: (()=>{ const n=Number(s.value); if(!Number.isFinite(n)) return 0; const pct = (n<=1.5 ? n*100 : n); return Math.max(0, Math.min(100, pct)); })(),
      weight: typeof s.weight === "number" ? s.weight : 1,
      group:
        s.group ??
        (s.key.includes(".") ? s.key.split(".").slice(0, 2).join(".") : s.key),
    }));

    // overall weighted avg
    const totW = norm.reduce((a, s) => a + (s.weight ?? 1), 0);
    const totS = norm.reduce((a, s) => a + s.value * (s.weight ?? 1), 0);
    const overall = totW > 0 ? totS / totW : 0;

    // OUTER ring: every TEKS except BIO.1–BIO.4 clusters
    // We want sub-TEKS like BIO.5A ... BIO.13D
    const outerSegments = norm.filter((s) => {
      // exclude practice cluster keys explicitly
      if (isPracticeClusterKey(s.key)) return false;
      // also exclude anything grouped as BIO.1-4 if you choose to store those separately
      if (isPracticeClusterKey(s.group ?? "")) return false;
      return true;
    });

    const outer: RingArc[] = outerSegments
      .slice()
      .sort(
        (a, b) =>
          (a.group ?? "").localeCompare(b.group ?? "") ||
          a.key.localeCompare(b.key),
      )
      .map((s) => ({
        key: s.key,
        label: s.label,
        weight: s.weight ?? 1,
        value: s.value,
        groupKey: s.group,
        groupLabel: s.group,
        color: outerColorFor(s.key),
      }));

    // INNER ring: BIO.1–BIO.4
    // If caller provided explicit BIO.1..BIO.4 segments, use those.
    // Otherwise compute from any segments whose group is BIO.1..BIO.4.
    const providedPractice = new Map<string, DonutSegment>();
    for (const s of norm) {
      if (isPracticeClusterKey(s.key)) providedPractice.set(s.key, s);
    }

    const byPractice = new Map<string, { weight: number; sum: number }>();
    for (const s of norm) {
      const g = s.group ?? "";
      if (!isPracticeClusterKey(g)) continue;
      const prev = byPractice.get(g) ?? { weight: 0, sum: 0 };
      prev.weight += s.weight ?? 1;
      prev.sum += s.value * (s.weight ?? 1);
      byPractice.set(g, prev);
    }

    const inner: RingArc[] = PRACTICE_KEYS.map((k) => {
      const explicit = providedPractice.get(k);
      if (explicit) {
        return {
          key: k,
          label: PRACTICE_LABELS[k],
          weight: explicit.weight ?? 1,
          value: explicit.value,
          color: innerColorFor(k, explicit.value),
        };
      }
      const agg = byPractice.get(k);
      const w = agg?.weight ?? 1;
      const v = agg && agg.weight > 0 ? agg.sum / agg.weight : 0;
      return {
        key: k,
        label: PRACTICE_LABELS[k],
        weight: w,
        value: v,
        color: innerColorFor(k, explicit.value),
      };
    });

    const hoverText = (key: string | null) => {
      if (!key) return "Hover a slice to see the TEKS.";
      const p = inner.find((x) => x.key === key);
      if (p) return p.label;
      const it = outer.find((x) => x.key === key);
      if (it) {
        const grp = it.groupLabel ? ` (${it.groupLabel})` : "";
        return `${it.key} • ${it.label}${grp}`;
      }
      return "Hover a slice to see the TEKS.";
    };

    return { outer, inner, overall, hoverText };
  }, [segments]);

  const cx = size / 2;
  const cy = size / 2;

  // Outer ring thick + inner ring thinner (like your preferred look)
  const rOuterOuter = size * 0.44;
  const rOuterInner = size * 0.34;

  const rInnerOuter = size * 0.3;
  const rInnerInner = size * 0.22;

  function renderRing(arcs: RingArc[], rOuter: number, rInner: number) {
    const total = arcs.reduce((a, x) => a + x.weight, 0) || 1;
    let ang = -Math.PI / 2;

    return arcs.map((a) => {
      const span = (a.weight / total) * Math.PI * 2;
      const start = ang;
      const end = ang + span;
      ang = end;

      const isHover = hoverKey === a.key;
      const dim = hoverKey ? (isHover ? 1 : 0.32) : 1;

      return (
        <path
          key={a.key}
          d={arcPath(cx, cy, rOuter, rInner, start, end)}
          fill={a.color}
          opacity={dim}
          onMouseEnter={() => setHoverKey(a.key)}
          onMouseLeave={() => setHoverKey(null)}
          style={{
            transition: "opacity 140ms ease, filter 140ms ease",
            filter: isHover
              ? "drop-shadow(0px 10px 16px rgba(0,0,0,0.18))"
              : "none",
            cursor: "pointer",
          }}
        />
      );
    });
  }

  const centerPct = Math.round(overall);

  return (
    <div className="flex flex-col items-center">
      <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>
        {/* Outer ring: BIO.5–BIO.13 sub-TEKS */}
        {renderRing(outer, rOuterOuter, rOuterInner)}

        {/* spacer rings */}
        <circle
          cx={cx}
          cy={cy}
          r={rOuterInner + 1}
          fill="white"
          opacity={0.98}
        />
        <circle
          cx={cx}
          cy={cy}
          r={rInnerOuter - 1}
          fill="white"
          opacity={0.98}
        />

        {/* Inner ring: BIO.1–BIO.4 */}
        {renderRing(inner, rInnerOuter, rInnerInner)}

        {/* center */}
        <circle cx={cx} cy={cy} r={rInnerInner - 6} fill="white" />

        <text
          x={cx}
          y={cy + 6}
          textAnchor="middle"
          fontSize="56"
          fill="#0f172a"
          fontWeight={800}
        >
          {centerPct}%
        </text>
        <text
          x={cx}
          y={cy + 42}
          textAnchor="middle"
          fontSize="16"
          fill="#64748b"
          fontWeight={600}
        >
          mastery
        </text>
      </svg>

      <div className="mt-3 text-base text-slate-600">{hoverText(hoverKey)}</div>
    </div>
  );
}

export default MasteryDonut;
