import type { Segment } from "@/types/segment";
"use client";

import React, { useMemo, useState } from "react";

export type DonutSegment = {
  key: string; // e.g. "BIO.10C" or "BIO.2"
  label: string;
  value: number; // 0..100 (or sometimes 0..1)
  weight?: number;
  group?: string; // e.g. "BIO.10" or "BIO.2"
};

type RingArc = {
  key: string;
  label: string;
  weight: number;
  value: number; // 0..100
  groupKey?: string;
  groupLabel?: string;
  color: string;
};

function polarToXY(cx: number, cy: number, r: number, a: number) {
  return { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
}

function arcPath(cx: number, cy: number, rOuter: number, rInner: number, start: number, end: number) {
  const large = end - start > Math.PI ? 1 : 0;
  const p1 = polarToXY(cx, cy, rOuter, start);
  const p2 = polarToXY(cx, cy, rOuter, end);
  const p3 = polarToXY(cx, cy, rInner, end);
  const p4 = polarToXY(cx, cy, rInner, start);

  return [
    `M ${p1.x.toFixed(3)} ${p1.y.toFixed(3)}`,
    `A ${rOuter} ${rOuter} 0 ${large} 1 ${p2.x.toFixed(3)} ${p2.y.toFixed(3)}`,
    `L ${p3.x.toFixed(3)} ${p3.y.toFixed(3)}`,
    `A ${rInner} ${rInner} 0 ${large} 0 ${p4.x.toFixed(3)} ${p4.y.toFixed(3)}`,
    "Z",
  ].join(" ");
}

function mixHex(a: string, b: string, t: number) {
  const pa = parseInt(a.slice(1), 16);
  const pb = parseInt(b.slice(1), 16);
  const ar = (pa >> 16) & 255,
    ag = (pa >> 8) & 255,
    ab = pa & 255;
  const br = (pb >> 16) & 255,
    bg = (pb >> 8) & 255,
    bb = pb & 255;

  const rr = Math.round(ar + (br - ar) * t);
  const rg = Math.round(ag + (bg - ag) * t);
  const rb = Math.round(ab + (bb - ab) * t);
  const toHex = (n: number) => n.toString(16).padStart(2, "0");
  return `#${toHex(rr)}${toHex(rg)}${toHex(rb)}`;
}

function hashStr(s: string) {
  let h = 2166136261;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

function toPct(v: number) {
  if (!Number.isFinite(v)) return 0;
  // support 0..1 inputs
  if (v >= 0 && v <= 1) return v * 100;
  return v;
}

/** Outer ring: make TEKS in same cluster share a base color (BIO.10, BIO.12, etc). */
const OUTER_CLUSTER_BASE: Record<string, string> = {
  "BIO.5": "#2563eb",  // blue
  "BIO.6": "#7c3aed",  // violet
  "BIO.7": "#db2777",  // pink
  "BIO.8": "#f59e0b",  // amber
  "BIO.9": "#16a34a",  // green
  "BIO.10": "#ef4444", // red
  "BIO.11": "#06b6d4", // cyan
  "BIO.12": "#22c55e", // green (brighter)
  "BIO.13": "#a855f7", // purple
};

const OUTER_SHADE_STEPS = 6;

function shadeOf(baseHex: string, idx: number) {
  // idx 0..steps-1 -> slightly different tints
  const t = idx / Math.max(1, OUTER_SHADE_STEPS - 1);
  return mixHex(baseHex, "#ffffff", 0.08 + 0.22 * t);
}

function clusterKeyFromSegmentKey(key: string) {
  // "BIO.10C" -> "BIO.10"
  const m = key.match(/^(BIO\.[0-9]+)/);
  return m ? m[1] : key;
}

function outerColorFor(key: string) {
  const cluster = clusterKeyFromSegmentKey(key);
  const base = OUTER_CLUSTER_BASE[cluster] ?? "#2563eb";

  // If there’s a trailing letter (A/B/C/D...), use it for stable shading.
  // Otherwise use a hash.
  const m = key.match(/([A-Z])$/); // trailing letter
  let idx = 0;

  if (m && m[1]) {
    idx = (m[1].charCodeAt(0) - 65) % OUTER_SHADE_STEPS; // A->0, B->1...
  } else {
    idx = hashStr(key) % OUTER_SHADE_STEPS;
  }

  return shadeOf(base, idx);
}

/** Inner ring: muted colors (BIO.1–BIO.4) */
const INNER_COLORS = ["#94a3b8", "#60a5fa", "#34d399", "#f59e0b"] as const;

const PRACTICE_KEYS = ["BIO.1", "BIO.2", "BIO.3", "BIO.4"] as const;

const PRACTICE_LABELS: Record<(typeof PRACTICE_KEYS)[number], string> = {
  "BIO.1": "BIO.1 • Ask questions, plan & conduct investigations safely",
  "BIO.2": "BIO.2 • Analyze & interpret data",
  "BIO.3": "BIO.3 • Develop explanations & communicate findings",
  "BIO.4": "BIO.4 • Scientists, research, and societal impact",
};

function isPracticeClusterKey(
  k: string
): k is (typeof PRACTICE_KEYS)[number] {
  return (PRACTICE_KEYS as readonly string[]).includes(k);
}

function innerColorFor(groupKey: string) {
  const idx = hashStr(groupKey) % INNER_COLORS.length;
  return INNER_COLORS[idx] ?? "#94a3b8";
}

export default function MasteryDonut({
  segments,
  size = 420,
}: {
  segments: DonutSegment[];
  size?: number;
}) {
  const [hoverKey, setHoverKey] = useState<string | null>(null);

  const { outer, inner, overall, hoverText } = useMemo(() => {
    const norm = segments.map((s) => ({
      ...s,
      value: toPct(s.value),
      weight: typeof s.weight === "number" ? s.weight : 1,
      group: s.group ?? (s.key.includes(".") ? s.key.split(".").slice(0, 2).join(".") : s.key),
    }));

    const totW = norm.reduce((a, s) => a + (s.weight ?? 1), 0);
    const totS = norm.reduce((a, s) => a + (s.value * (s.weight ?? 1)), 0);
    const overall = totW > 0 ? totS / totW : 0;

    const outerSegments = norm.filter((s) => {
      if (isPracticeClusterKey(s.key)) return false;
      if (isPracticeClusterKey(s.group ?? "")) return false;
      return true;
    });

    const outer: RingArc[] = outerSegments
      .slice()
      .sort((a, b) => (a.group ?? "").localeCompare(b.group ?? "") || a.key.localeCompare(b.key))
      .map((s) => ({
        key: s.key,
        label: s.label,
        weight: s.weight ?? 1,
        value: s.value,
        groupKey: s.group,
        groupLabel: s.group,
        color: outerColorFor(s.key),
      }));

    const providedPractice = new Map<string, DonutSegment>();
    for (const s of norm) {
      if (isPracticeClusterKey(s.key)) providedPractice.set(s.key, s);
    }

    const byPractice = new Map<string, { weight: number; sum: number }>();
    for (const s of norm) {
      const g = s.group ?? "";
      if (!isPracticeClusterKey(g)) continue;
      const prev = byPractice.get(g) ?? { weight: 0, sum: 0 };
      prev.weight += s.weight ?? 1;
      prev.sum += s.value * (s.weight ?? 1);
      byPractice.set(g, prev);
    }

    const inner: RingArc[] = PRACTICE_KEYS.map((k) => {
      const explicit = providedPractice.get(k);
      if (explicit) {
        return {
          key: k,
          label: PRACTICE_LABELS[k],
          weight: explicit.weight ?? 1,
          value: toPct(explicit.value),
          color: innerColorFor(k),
        };
      }
      const agg = byPractice.get(k);
      const w = agg?.weight ?? 1;
      const v = agg && agg.weight > 0 ? agg.sum / agg.weight : 0;
      return {
        key: k,
        label: PRACTICE_LABELS[k],
        weight: w,
        value: v,
        color: innerColorFor(k),
      };
    });

    const hoverText = (key: string | null) => {
      if (!key) return "Hover a slice to see the TEKS.";
      const p = inner.find((x) => x.key === key);
      if (p) return p.label;
      const it = outer.find((x) => x.key === key);
      if (it) {
        const grp = it.groupLabel ? ` (${it.groupLabel})` : "";
        return `${it.key} • ${it.label}${grp}`;
      }
      return "Hover a slice to see the TEKS.";
    };

    return { outer, inner, overall, hoverText };
  }, [segments]);

  const cx = size / 2;
  const cy = size / 2;

  const rOuterOuter = size * 0.44;
  const rOuterInner = size * 0.34;

  const rInnerOuter = size * 0.30;
  const rInnerInner = size * 0.22;

  function renderRing(arcs: RingArc[], rOuter: number, rInner: number) {
    const total = arcs.reduce((a, x) => a + x.weight, 0) || 1;
    let ang = -Math.PI / 2;

    return arcs.map((a) => {
      const span = (a.weight / total) * Math.PI * 2;
      const start = ang;
      const end = ang + span;
      ang = end;

      const isHover = hoverKey === a.key;
      const dim = hoverKey ? (isHover ? 1 : 0.32) : 1;

      return (
        <path
          key={a.key}
          d={arcPath(cx, cy, rOuter, rInner, start, end)}
          fill={a.color}
          opacity={dim}
          onMouseEnter={() => setHoverKey(a.key)}
          onMouseLeave={() => setHoverKey(null)}
          style={{
            transition: "opacity 140ms ease, filter 140ms ease",
            filter: isHover ? "drop-shadow(0px 10px 16px rgba(0,0,0,0.18))" : "none",
            cursor: "default",
          }}
        />
      );
    });
  }

  const centerPct = Math.round(overall);

  return (
    <div className="flex flex-col items-center">
      <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>
        {renderRing(outer, rOuterOuter, rOuterInner)}

        <circle cx={cx} cy={cy} r={rOuterInner + 1} fill="white" opacity={0.98} />
        <circle cx={cx} cy={cy} r={rInnerOuter - 1} fill="white" opacity={0.98} />

        {renderRing(inner, rInnerOuter, rInnerInner)}

        <circle cx={cx} cy={cy} r={rInnerInner - 6} fill="white" />

        <text x={cx} y={cy + 6} textAnchor="middle" fontSize="56" fill="#0f172a" fontWeight={800}>
          {centerPct}%
        </text>
        <text x={cx} y={cy + 42} textAnchor="middle" fontSize="16" fill="#64748b" fontWeight={600}>
          mastery
        </text>
      </svg>

      <div className="mt-3 text-center text-sm text-slate-600">{hoverText(hoverKey)}</div>
    </div>
  );
}
