"use client";

import React, { useMemo, useState } from "react";

export type DonutSegment = {
  key: string;          // e.g. "BIO.10C" or "BIO.2"
  label: string;        // human label
  value: number;        // 0-100 mastery
  weight?: number;      // slice size weight
  group?: string;       // e.g. "BIO.10" or "BIO.2"
};

type RingArc = {
  key: string;
  label: string;
  weight: number;
  value: number;
  groupKey?: string;
  groupLabel?: string;
  color: string;
};

function polarToXY(cx: number, cy: number, r: number, a: number) {
  return { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
}

function arcPath(cx: number, cy: number, rOuter: number, rInner: number, start: number, end: number) {
  const large = end - start > Math.PI ? 1 : 0;
  const p1 = polarToXY(cx, cy, rOuter, start);
  const p2 = polarToXY(cx, cy, rOuter, end);
  const p3 = polarToXY(cx, cy, rInner, end);
  const p4 = polarToXY(cx, cy, rInner, start);

  return [
    `M ${p1.x.toFixed(3)} ${p1.y.toFixed(3)}`,
    `A ${rOuter} ${rOuter} 0 ${large} 1 ${p2.x.toFixed(3)} ${p2.y.toFixed(3)}`,
    `L ${p3.x.toFixed(3)} ${p3.y.toFixed(3)}`,
    `A ${rInner} ${rInner} 0 ${large} 0 ${p4.x.toFixed(3)} ${p4.y.toFixed(3)}`,
    "Z",
  ].join(" ");
}

function mixHex(a: string, b: string, t: number) {
  const pa = parseInt(a.slice(1), 16);
  const pb = parseInt(b.slice(1), 16);
  const ar = (pa >> 16) & 255, ag = (pa >> 8) & 255, ab = pa & 255;
  const br = (pb >> 16) & 255, bg = (pb >> 8) & 255, bb = pb & 255;
  const rr = Math.round(ar + (br - ar) * t);
  const rg = Math.round(ag + (bg - ag) * t);
  const rb = Math.round(ab + (bb - ab) * t);
  const toHex = (n: number) => n.toString(16).padStart(2, "0");
  return `#${toHex(rr)}${toHex(rg)}${toHex(rb)}`;
}

function hashStr(s: string) {
  let h = 2166136261;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

const OUTER_PALETTE = [
  "#2d46d6", "#5a35d6", "#d62d6f", "#c026d3",
  "#7c3aed", "#2563eb", "#16a34a", "#22c55e",
  "#eab308", "#f59e0b", "#ef4444", "#f97316",
  "#84cc16", "#06b6d4", "#6366f1", "#a855f7",
];

function outerColorFor(key: string) {
  return OUTER_PALETTE[hashStr(key) % OUTER_PALETTE.length];
}

// Inner ring palette: calm “sand” with slight per-slice variation
const INNER_BASE = "#e7d6a8";
const INNER_TINTS = ["#ffffff", "#f8fafc", "#f1f5f9"];

function innerColorFor(groupKey: string) {
  const idx = hashStr(groupKey) % INNER_TINTS.length;
  return mixHex(INNER_BASE, INNER_TINTS[idx], 0.10);
}

const PRACTICE_KEYS = ["BIO.1", "BIO.2", "BIO.3", "BIO.4"] as const;

const PRACTICE_LABELS: Record<(typeof PRACTICE_KEYS)[number], string> = {
  "BIO.1": "BIO.1 • Ask questions, plan & conduct investigations safely",
  "BIO.2": "BIO.2 • Analyze & interpret data",
  "BIO.3": "BIO.3 • Develop explanations & communicate findings",
  "BIO.4": "BIO.4 • Scientists, research, and societal impact",
};

function isPracticeClusterKey(k: string) {
  return PRACTICE_KEYS.includes(k as any);
}

export function MasteryDonut({
  segments,
  size = 420,
}: {
  segments: DonutSegment[];
  size?: number;
}) {
  const [hoverKey, setHoverKey] = useState<string | null>(null);

  const { outer, inner, overall, hoverText } = useMemo(() => {
    const norm = segments.map((s) => ({
      ...s,
      weight: typeof s.weight === "number" ? s.weight : 1,
      group: s.group ?? (s.key.includes(".") ? s.key.split(".").slice(0, 2).join(".") : s.key),
    }));

    // overall weighted avg
    const totW = norm.reduce((a, s) => a + (s.weight ?? 1), 0);
    const totS = norm.reduce((a, s) => a + s.value * (s.weight ?? 1), 0);
    const overall = totW > 0 ? totS / totW : 0;

    // OUTER ring: every TEKS except BIO.1–BIO.4 clusters
    // We want sub-TEKS like BIO.5A ... BIO.13D
    const outerSegments = norm.filter((s) => {
      // exclude practice cluster keys explicitly
      if (isPracticeClusterKey(s.key)) return false;
      // also exclude anything grouped as BIO.1-4 if you choose to store those separately
      if (isPracticeClusterKey(s.group ?? "")) return false;
      return true;
    });

    const outer: RingArc[] = outerSegments
      .slice()
      .sort((a, b) => (a.group ?? "").localeCompare(b.group ?? "") || a.key.localeCompare(b.key))
      .map((s) => ({
        key: s.key,
        label: s.label,
        weight: s.weight ?? 1,
        value: s.value,
        groupKey: s.group,
        groupLabel: s.group,
        color: outerColorFor(s.key),
      }));

    // INNER ring: BIO.1–BIO.4
    // If caller provided explicit BIO.1..BIO.4 segments, use those.
    // Otherwise compute from any segments whose group is BIO.1..BIO.4.
    const providedPractice = new Map<string, DonutSegment>();
    for (const s of norm) {
      if (isPracticeClusterKey(s.key)) providedPractice.set(s.key, s);
    }

    const byPractice = new Map<string, { weight: number; sum: number }>();
    for (const s of norm) {
      const g = s.group ?? "";
      if (!isPracticeClusterKey(g)) continue;
      const prev = byPractice.get(g) ?? { weight: 0, sum: 0 };
      prev.weight += s.weight ?? 1;
      prev.sum += s.value * (s.weight ?? 1);
      byPractice.set(g, prev);
    }

    const inner: RingArc[] = PRACTICE_KEYS.map((k) => {
      const explicit = providedPractice.get(k);
      if (explicit) {
        return {
          key: k,
          label: PRACTICE_LABELS[k],
          weight: explicit.weight ?? 1,
          value: explicit.value,
          color: innerColorFor(k),
        };
      }
      const agg = byPractice.get(k);
      const w = agg?.weight ?? 1;
      const v = agg && agg.weight > 0 ? agg.sum / agg.weight : 0;
      return {
        key: k,
        label: PRACTICE_LABELS[k],
        weight: w,
        value: v,
        color: innerColorFor(k),
      };
    });

    const hoverText = (key: string | null) => {
      if (!key) return "Hover a slice to see the TEKS.";
      const p = inner.find((x) => x.key === key);
      if (p) return p.label;
      const it = outer.find((x) => x.key === key);
      if (it) {
        const grp = it.groupLabel ? ` (${it.groupLabel})` : "";
        return `${it.key} • ${it.label}${grp}`;
      }
      return "Hover a slice to see the TEKS.";
    };

    return { outer, inner, overall, hoverText };
  }, [segments]);

  const cx = size / 2;
  const cy = size / 2;

  // Outer ring thick + inner ring thinner (like your preferred look)
  const rOuterOuter = size * 0.44;
  const rOuterInner = size * 0.34;

  const rInnerOuter = size * 0.30;
  const rInnerInner = size * 0.22;

  function renderRing(arcs: RingArc[], rOuter: number, rInner: number) {
    const total = arcs.reduce((a, x) => a + x.weight, 0) || 1;
    let ang = -Math.PI / 2;

    return arcs.map((a) => {
      const span = (a.weight / total) * Math.PI * 2;
      const start = ang;
      const end = ang + span;
      ang = end;

      const isHover = hoverKey === a.key;
      const dim = hoverKey ? (isHover ? 1 : 0.32) : 1;

      return (
        <path
          key={a.key}
          d={arcPath(cx, cy, rOuter, rInner, start, end)}
          fill={a.color}
          opacity={dim}
          onMouseEnter={() => setHoverKey(a.key)}
          onMouseLeave={() => setHoverKey(null)}
          style={{
            transition: "opacity 140ms ease, filter 140ms ease",
            filter: isHover ? "drop-shadow(0px 10px 16px rgba(0,0,0,0.18))" : "none",
            cursor: "default",
          }}
        />
      );
    });
  }

  const centerPct = Math.round(overall);

  return (
    <div className="flex flex-col items-center">
      <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>
        {/* Outer ring: BIO.5–BIO.13 sub-TEKS */}
        {renderRing(outer, rOuterOuter, rOuterInner)}

        {/* spacer rings */}
        <circle cx={cx} cy={cy} r={rOuterInner + 1} fill="white" opacity={0.98} />
        <circle cx={cx} cy={cy} r={rInnerOuter - 1} fill="white" opacity={0.98} />

        {/* Inner ring: BIO.1–BIO.4 */}
        {renderRing(inner, rInnerOuter, rInnerInner)}

        {/* center */}
        <circle cx={cx} cy={cy} r={rInnerInner - 6} fill="white" />

        <text x={cx} y={cy + 6} textAnchor="middle" fontSize="56" fill="#0f172a" fontWeight={800}>
          {centerPct}%
        </text>
        <text x={cx} y={cy + 42} textAnchor="middle" fontSize="16" fill="#64748b" fontWeight={600}>
          mastery
        </text>
      </svg>

      <div className="mt-3 text-base text-slate-600">{hoverText(hoverKey)}</div>
    </div>
  );
}

export default MasteryDonut;
